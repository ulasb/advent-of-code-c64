# Advent of Code 2015 - Day 19 (C64 Edition)

This is a Commodore 64 implementation of Advent of Code 2015 Day 19, written in C and compiled with cc65.

## The Problem

**Day 19: Medicine for Rudolph**

Rudolph the Red-Nosed Reindeer is sick! We need to calibrate the medicine machine.
- **Part 1:** Given a molecule and a list of replacements, how many *distinct* molecules can be generated by making exactly one replacement? ✅ **Implemented**
- **Part 2:** Calculate the minimum number of steps to generate the medicine molecule from a single electron (`e`) using the replacements. ⚠️ **Not implemented** (see Known Limitations)

## Running the Program

### Requirements
- [cc65](https://cc65.github.io/) compiler suite
- [VICE](https://vice-emu.sourceforge.io/) or another C64 emulator (like `x64`)

### Compilation
To compile the program, run:
```bash
make
```
This produces `day19.prg`.

### Testing
To run it in VICE:
```bash
make run
```
Or load `day19.prg` manually into your emulator.

The program will run automated tests and display results on screen. Press Enter to exit when complete.

## Test Cases Included

Since the C64 has limited memory and I/O capabilities, we use hardcoded test cases derived from the problem description to verify the solution logic.

### Part 1 Tests
- **Input:** Molecule `HOH`, Replacements `H=>HO`, `H=>OH`, `O=>HH`
  - **Expected:** 4 distinct molecules ✅
- **Input:** Molecule `HOHOHO`, same replacements
  - **Expected:** 7 distinct molecules ✅

## Known Limitations

### Part 2 Not Implemented

Part 2 (reverse molecule generation) is **not included** in this C64 version due to platform instability. The algorithm requires complex string manipulation with dynamic shuffling and potentially unbounded retry logic, which proved unreliable when ported to C for the C64.

For Part 2 solutions, please refer to the Python implementation at: https://github.com/ulasb/advent-of-code-python/tree/main/2015/day_19/

## Technical Notes - Part 1 Implementation

### Algorithm

**Molecule Generation Strategy:**
- For each replacement rule, scan the input molecule for all occurrences of the pattern
- At each occurrence, generate a new molecule by applying the replacement
- Use linear search to filter out duplicate molecules
- Store unique molecules in a global array
- Complexity: O(n × m × l) where n = replacements, m = molecule length, l = unique molecules

### C64-Specific Challenges and Solutions

#### 1. Stack Limitations
**Problem:** The C64's 6502 processor has a very small hardware stack (256 bytes), and `cc65` enforces strict limits on local variables.

**Solution:** Move large buffers to global scope (BSS segment):
```c
char generated_molecules[MAX_GENERATED_MOLECULES][MAX_MOLECULE_LEN];
char part1_new_mol[MAX_MOLECULE_LEN];
```

#### 2. Memory Constraints
**Problem:** The C64 has only 64KB total RAM, and the BSS segment has strict size limits.

**Solution:** Reduce buffer sizes to fit within available memory:
```c
#define MAX_REPLACEMENTS 10        // Sufficient for test cases
#define MAX_MOLECULE_LEN 64        // Reduced from typical 512
#define MAX_GENERATED_MOLECULES 10 // Limited unique molecule storage
```

#### 3. Output Reliability
**Problem:** Standard `stdio.h` functions (`printf`) were unreliable on C64 - output would flash briefly then disappear or crash.

**Solution:** Use `conio.h` for direct screen access:
```c
#include <conio.h>
cprintf("TEXT\r\n");  // Use \r\n instead of \n
clrscr();             // Clear screen
bgcolor(COLOR_BLUE);  // Set colors
```

Benefits:
- No buffering issues
- Direct character-mode output
- Reliable on C64 hardware
- Screen persists until explicitly cleared

#### 4. Program Exit Behavior
**Problem:** When `main()` returns, the C64 immediately returns to BASIC, clearing the screen.

**Solution:** Wait for user input before exiting:
```c
cprintf("\r\nPRESS ENTER TO EXIT.\r\n");
cgetc(); // Wait for any key press
```

#### 5. C89 Compliance
**Problem:** `cc65` requires strict C89 compliance - all variables must be declared at the beginning of their scope.

**Solution:** Declare all variables at function start:
```c
int solve_part1(const char *molecule, Replacement replacements[], int count) {
  int unique_count = 0;
  int i, j, pos;        // All declared upfront
  const char *p;
  // ... rest of function
}
```

#### 6. String Manipulation Optimization
**Solution:** Use `memcpy()` for efficient, bounds-safe string operations:
```c
void str_replace_at(char *dest, const char *src, int pos, 
                    const char *old_str, const char *new_str) {
  int old_len = strlen(old_str);
  int new_len = strlen(new_str);
  const char *suffix = src + pos + old_len;
  int suffix_len = strlen(suffix);

  memcpy(dest, src, pos);                      // Copy prefix
  memcpy(dest + pos, new_str, new_len);        // Copy replacement
  memcpy(dest + pos + new_len, suffix, suffix_len + 1); // Copy suffix + null
}
```

This is faster and safer than loop-based character copying.

### Performance

- **Part 1:** Fast - completes in under a second
- Test cases execute almost instantly on C64 hardware

### Why These Constraints Matter

The C64 is a severely resource-constrained platform compared to modern systems:
- **CPU:** 1 MHz 6502 (vs GHz multi-core)
- **RAM:** 64 KB total (vs GB)
- **Stack:** 256 bytes (vs MB)
- **No virtual memory or dynamic allocation safety**

Every byte and CPU cycle counts. The implementation prioritizes:
1. **Correctness** - Get the right answer
2. **Stability** - Don't crash
3. **Simplicity** - Keep code maintainable
4. **Efficiency** - Minimize memory and CPU usage

## Files

- `day19.c` - Main source code (Part 1 implementation only)
- `Makefile` - Build script for cc65
- `README.md` - This file
- `day19.prg` - Compiled C64 executable (after running `make`)

## Building from Scratch

If you need to rebuild everything:
```bash
make clean  # Remove all build artifacts
make        # Rebuild day19.prg
make run    # Compile and run in VICE
```

## Debugging Tips

If you encounter issues:
1. **Black/gray screen hang:** Check that `conio.h` is being used, not `stdio.h`
2. **"Too many local variables" error:** Move large arrays to global scope
3. **BSS segment overflow:** Reduce `MAX_*` constants
4. **Immediate exit:** Ensure `cgetc()` is called before `return 0`

---

## Appendix: Design Notes for Unimplemented Part 2

This section documents the challenges encountered when attempting to implement Part 2 on the C64.

### Part 2 Algorithm (Theoretical)

The intended approach for Part 2 was:
- **Reverse Greedy Search:** Work backwards from target molecule to `e`
- Reverse all replacement rules (e.g., `H=>HO` becomes `HO=>H`)
- Sort reversed rules by pattern length (descending) to prioritize longer reductions
- **Greedy algorithm:** Apply first matching rule, repeat until reaching `e`
- **Randomization:** If stuck, shuffle rules and restart from target
- **Timeout protection:** Maximum retry attempts to prevent infinite loops

### Why Part 2 Failed on C64

1. **Random Number Generator Issues:** `rand()` behavior on C64 without proper seeding proved unreliable
2. **Complex String State:** The algorithm maintains multiple string buffers and performs many allocations
3. **Unbounded Retry Logic:** The shuffle-and-retry mechanism could hang or crash
4. **Memory Pressure:** Additional data structures (`ReverseReplacement`) pushed close to BSS limits

### What We Learned

The C64 platform has hard limits that modern algorithms take for granted:
- Algorithms relying on good randomness need careful seeding (no `time()` on C64)
- Unbounded loops need very conservative timeouts
- String manipulation must be extremely careful about bounds
- Some algorithms simply don't fit the platform constraints

The Python implementation works perfectly because it has:
- Reliable random number generation
- Dynamic memory allocation
- No stack/BSS segment limits
- Fast string operations

For historical computing platforms, **simpler is better**. Part 1's deterministic algorithm fits the C64 perfectly. Part 2's stochastic search does not.
