# Advent of Code 2015 - Day 19 (C64 Edition)

This is a Commodore 64 implementation of Advent of Code 2015 Day 19, written in C and compiled with cc65.

## The Problem

**Day 19: Medicine for Rudolph**

Rudolph the Red-Nosed Reindeer is sick! We need to calibrate the medicine machine.
- **Part 1:** Given a molecule and a list of replacements, how many *distinct* molecules can be generated by making exactly one replacement? ✅ **Implemented**
- **Part 2:** Calculate the minimum number of steps to generate the medicine molecule from a single electron (`e`) using the replacements. ⚠️ **Not implemented** (see Known Limitations below)

## Running the Program

### Requirements
- [cc65](https://cc65.github.io/) compiler suite
- [VICE](https://vice-emu.sourceforge.io/) or another C64 emulator (like `x64`)

### Compilation
To compile the program, run:
```bash
make
```
This produces `day19.prg`.

### Testing
To run it in VICE:
```bash
make run
```
Or load `day19.prg` manually into your emulator.

The program will run automated tests and display results on screen. Press Enter to exit when complete.

## Test Cases Included

Since the C64 has limited memory and I/O capabilities, we use hardcoded test cases derived from the problem description to verify the solution logic.

### Part 1 Tests
- **Input:** Molecule `HOH`, Replacements `H=>HO`, `H=>OH`, `O=>HH`
  - **Expected:** 4 distinct molecules
- **Input:** Molecule `HOHOHO`, same replacements
  - **Expected:** 7 distinct molecules

## Known Limitations

### Part 2 Not Implemented

Part 2 (reverse molecule generation) is **not included** in this C64 version due to platform instability. The algorithm requires:
- Dynamic shuffling with `rand()` which may not work reliably on C64
- Complex string manipulation in tight loops
- Potentially unbounded retry logic

Attempts to implement Part 2 resulted in crashes and hangs on the C64 platform. The algorithm works fine in the Python reference implementation but exceeds the C64's capabilities when ported to C with cc65.

For Part 2 solutions, please refer to the Python implementation at: https://github.com/ulasb/advent-of-code-python/tree/main/2015/day_19/

## Technical Notes

### Algorithm Implementation

#### Part 1: Molecule Generation
- Brute-force generation: for each replacement rule, scan the molecule for all occurrences of the pattern
- Replace each occurrence to generate a new molecule
- Use linear search to filter duplicates (store in global array)
- Complexity: O(n × m × l) where n = replacements, m = molecule length, l = unique molecules generated

#### Part 2: Reverse Greedy Search
- **Strategy:** Work backwards from target molecule to `e` (more efficient than forward search)
- Reverse all replacement rules (e.g., `H=>HO` becomes `HO=>H`)
- Sort reversed rules by pattern length (descending) to prioritize longer reductions
- **Greedy algorithm:** Apply first matching rule, repeat until reaching `e`
- **Randomization:** If stuck (no rule matches), shuffle rules and restart from target
- **Timeout protection:** Maximum 100 retry attempts to prevent infinite loops
- This approach works because the AoC grammar structure tends to reduce deterministically in reverse

### C64-Specific Challenges and Solutions

#### 1. Stack Limitations
**Problem:** The C64's 6502 processor has a very small hardware stack (256 bytes), and `cc65` enforces strict limits on local variables.

**Solution:** Move all large buffers to global scope (BSS segment):
```c
char generated_molecules[MAX_GENERATED_MOLECULES][MAX_MOLECULE_LEN];
char part1_new_mol[MAX_MOLECULE_LEN];
char part2_temp_buffer[MAX_MOLECULE_LEN];
char current_molecule[MAX_MOLECULE_LEN];
ReverseReplacement global_rev_replacements[MAX_REPLACEMENTS];
```

#### 2. Memory Constraints
**Problem:** The C64 has only 64KB total RAM, and the BSS segment has strict size limits.

**Solution:** Reduce buffer sizes to fit within available memory:
```c
#define MAX_REPLACEMENTS 10        // Down from 50
#define MAX_MOLECULE_LEN 64        // Down from 512
#define MAX_GENERATED_MOLECULES 10 // Down from 100
```
These limits are sufficient for the test cases while staying within the C64's memory budget.

#### 3. Output Reliability
**Problem:** Standard `stdio.h` functions (`printf`) were unreliable on C64 - output would flash briefly then disappear or crash.

**Solution:** Use `conio.h` for direct screen access:
```c
#include <conio.h>
cprintf("TEXT\r\n");  // Use \r\n instead of \n
clrscr();             // Clear screen
bgcolor(COLOR_BLUE);  // Set colors
```
Benefits:
- No buffering issues
- Direct character-mode output
- Reliable on C64 hardware
- Screen persists until explicitly cleared

#### 4. Program Exit Behavior
**Problem:** When `main()` returns, the C64 immediately returns to BASIC, clearing the screen.

**Solution:** Wait for user input before exiting:
```c
cprintf("\r\nPRESS ENTER TO EXIT.\r\n");
cgetc(); // Wait for any key press
```
This keeps test results visible until the user is ready to exit.

#### 5. Standard Library Limitations
**Problem:** `time.h` and `time(0)` are not reliably supported on the C64 without a hardware real-time clock.

**Solution:** Use fixed seed for random number generator:
```c
srand(123); // Fixed seed instead of time(0)
```
This provides reproducible shuffle behavior for the Part 2 algorithm.

#### 6. C89 Compliance
**Problem:** `cc65` requires strict C89 compliance - all variables must be declared at the beginning of their scope.

**Solution:** Declare all variables at function start:
```c
int solve_part1(const char *molecule, Replacement replacements[], int count) {
  int unique_count = 0;
  int i, j, pos;        // All declared upfront
  const char *p;
  const char *rep_from;
  // ... rest of function
}
```

#### 7. String Manipulation
**Problem:** Complex pointer arithmetic and in-place modifications caused crashes.

**Solution:** Use simple loop-based string operations with explicit bounds checking:
```c
void str_replace_at(char *dest, const char *src, int pos, 
                    const char *old_str, const char *new_str) {
  int i;
  for (i = 0; i < pos; i++) {
    dest[i] = src[i];  // Manual copy
  }
  strcpy(dest + pos, new_str);
  strcat(dest, src + pos + strlen(old_str));
}
```

### Performance Characteristics

- **Part 1:** Fast - completes in under a second
- **Part 2:** Variable - depends on random shuffle luck
  - Best case: 3-5 attempts
  - Worst case: may timeout after 100 attempts (rare with seed 123)
  - Average: 10-20 attempts

### Why These Constraints Matter

The C64 is a severely resource-constrained platform compared to modern systems:
- **CPU:** 1 MHz 6502 (vs GHz multi-core)
- **RAM:** 64 KB total (vs GB)
- **Stack:** 256 bytes (vs MB)
- **No virtual memory or dynamic allocation safety**

Every byte and CPU cycle counts. The implementation prioritizes:
1. **Correctness** - Get the right answer
2. **Stability** - Don't crash
3. **Simplicity** - Keep code maintainable
4. **Efficiency** - Minimize memory and CPU usage

## Files

- `day19.c` - Main source code with both Part 1 and Part 2 implementations
- `Makefile` - Build script for cc65
- `README.md` - This file
- `day19.prg` - Compiled C64 executable (after running `make`)

## Building from Scratch

If you need to rebuild everything:
```bash
make clean  # Remove all build artifacts
make        # Rebuild day19.prg
make run    # Compile and run in VICE
```

## Debugging Tips

If you encounter issues:
1. **Black/gray screen hang:** Check that `conio.h` is being used, not `stdio.h`
2. **"Too many local variables" error:** Move large arrays to global scope
3. **BSS segment overflow:** Reduce `MAX_*` constants
4. **Immediate exit:** Ensure `cgetc()` is called before `return 0`
5. **Part 2 timeout:** Try different random seeds or increase `max_retries`
